<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Practical PKI - 01-keygen-and-csr</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <script src="../js/copy-button.js"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Practical PKI</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
            </div>
        </div>

        <div id="content">
            <div id="postContent">
    <h1 id="key-generation-and-csr-creation-with-openssl">Key generation and CSR creation with OpenSSL</h1>
<h2 id="introduction">Introduction <a href="#introduction" class="section">§</a></h2>
<p>Before a Certificate Authority (CA) can issue you an X.509
certificate, you must first create a <strong>Public/Private Key Pair</strong> and
a <strong>Certificate Signing Request (CSR)</strong>. The private key is the
secret component that proves your identity, and the CSR contains
your public key and identity information (like a website’s domain
name or a user’s email address) that the CA will embed in the final
certificate.</p>
<p>In this module you’ll use the <code>openssl</code> command line tool to
generate keys and create CSRs.</p>
<div class="note">
<p>All steps in this module are to be performed on <code>client.$DOMAIN</code>.
SSH into this machine now:</p>
<pre class="command"><code>ssh -i path/to/key.pem fedora@client.e$N.pki.frase.id.au</code></pre>
</div>
<h2 id="service-csr-with-rsa-key">Service CSR with RSA key <a href="#service-csr-with-rsa-key" class="section">§</a></h2>
<p>Let’s prepare a CSR suitable for a network service, such as an HTTP
server. We will use a strong RSA key and include the DNS hostname
in both the Common Name (CN) field and the Subject Alternative Name
(SAN) extension.</p>
<h3 id="generate-the-rsa-private-key">Generate the RSA Private Key <a href="#generate-the-rsa-private-key" class="section">§</a></h3>
<p>We will use the <strong>RSA 3072-bit</strong> key size, which is the minimum RSA
key size currently recommended by NIST for secure services.</p>
<pre class="command client"><code>openssl genpkey \
    -aes256 \
    -algorithm RSA \
    -pkeyopt rsa_keygen_bits:3072 \
    -out service.key</code></pre>
<p>The <code>-algorithm</code> and <code>-pkeyopt</code> arguments specify the public key
algorithm and key parameters. <code>-out</code> is where to write the
generated key.</p>
<p><strong>When storing keys in disk you should encrypt them.</strong> The
<code>-aes256</code> option selects AES-256 for key encryption. The command
will prompt you for a passphrase:</p>
<pre class="output"><code>Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:</code></pre>
<p>In real world use you should choose a secure passphrase (or store
keys in a <em>hardware security module (HSM)</em>, <em>secure element</em> or
<em>TPM</em>). For the purposes of this workshop choose something short
and memorable (e.g. <code>hunter2</code>). Note that you will not see any
output as you type the passphrase.</p>
<h3 id="create-config-file-for-service-csr">Create config file for service CSR <a href="#create-config-file-for-service-csr" class="section">§</a></h3>
<p>Create a configuration file to tell <code>openssl</code> what content to
include in the CSR. The certificate binds a public key to some
identity information. For a host or network service, this is often
just the DNS name used to reach it.</p>
<p>Open an editor (<code>vi</code> or <code>nano</code>) and create a file named
<code>service_csr.cnf</code> with the following content. <strong>Replace <code>$DOMAIN</code>
with your environment’s domain.</strong></p>
<pre><code>[ req ]
default_bits        = 3072
prompt              = no
default_md          = sha256
req_extensions      = req_ext
distinguished_name  = dn

[ dn ]
# NOTE: In real-world use cases, you may need to include
# other attributes (Country, Organization, etc.)
commonName = client.$DOMAIN

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
# The DNS name MUST match the Common Name for best practice.
DNS.1 = client.$DOMAIN</code></pre>
<h3 id="generate-the-service-csr">Generate the service CSR <a href="#generate-the-service-csr" class="section">§</a></h3>
<p>Execute the <code>openssl req</code> command below to build a CSR according to
the config file and sign it with the private key. Note that it will
prompt you for the encryption passphrase you set previously.</p>
<pre class="command client"><code>openssl req -new \
    -key service.key \
    -config service_csr.cnf \
    -out service.csr</code></pre>
<pre class="output"><code>Enter pass phrase for service.key:</code></pre>
<h3 id="verify-the-service-csr">Verify the service CSR <a href="#verify-the-service-csr" class="section">§</a></h3>
<p>Always verify your CSRs before submission to ensure the required
extensions and names are correctly included.</p>
<p>Check the SAN and key parameters for the service request.</p>
<pre class="command client"><code>openssl req -in service.csr -text -noout</code></pre>
<p>Look for the following in the output:</p>
<pre class="output"><code>  Subject Public Key Info:
      Public Key Algorithm: rsaEncryption
          Public-Key: (3072 bit)</code></pre>
<p>…and…</p>
<pre class="output"><code>    Requested Extensions:
        X509v3 Subject Alternative Name:
            DNS:client.$DOMAIN  -- your env's domain here</code></pre>
<h2 id="csr-for-user-certificate-with-ecc-key">CSR for user certificate with ECC key <a href="#csr-for-user-certificate-with-ecc-key" class="section">§</a></h2>
<p>X.509 certificates can be used for a variety of <strong>user
authentication</strong> scenarios (e.g. Kerberos, VPN access, email
signing). We use RSA for the service key, so let’s choose a
different algorithm for the user certificate.</p>
<p><em>Elliptic curve cryptography (ECC)</em> is an alternative to RSA. ECC
is faster than RSA, and keys and signatures are smaller. We’ll
generate an elliptic curve key and use it to sign a CSR that
includes the user’s <strong>username</strong> and <strong>email address</strong>.</p>
<h3 id="generate-the-ecc-private-key">Generate the ECC Private Key <a href="#generate-the-ecc-private-key" class="section">§</a></h3>
<p>We will use the <strong>secp384r1</strong> curve, which is recommended for high
security with efficient performance.</p>
<pre class="command client"><code>openssl genpkey \
    -aes256 \
    -algorithm EC \
    -pkeyopt ec_paramgen_curve:secp384r1 \
    -out user.key</code></pre>
<p>Again, choose a simple encryption passphrase for the purposes of
this workshop.</p>
<h3 id="create-config-file-for-user-csr">Create config file for user CSR <a href="#create-config-file-for-user-csr" class="section">§</a></h3>
<p>For user authentication certificates, the primary identifiers are
usually the username (in CN) and the email address (in the SAN).</p>
<div class="note">
<p>Set the <code>DOMAIN</code> shell variable, so that substitutions in shell
commands work:</p>
<pre class="command client no-copy"><code>DOMAIN=e17.pki.frase.id.au</code></pre>
<p>Also set the <code>REALM</code> shell variable (based on <code>$DOMAIN</code>):</p>
<pre class="command client"><code>REALM=$(echo $DOMAIN | tr '[:lower:]' '[:upper:]')</code></pre>
</div>
<p>Create a file named <code>user_csr.cnf</code> with an OpenSSL configuration
suitable for requesting an authentication certificate for <code>user1</code>:</p>
<pre class="command client"><code>tee user_csr.cnf &gt;/dev/null &lt;&lt;EOF
[ req ]
prompt              = no
req_extensions      = req_ext
distinguished_name  = dn

[ dn ]
commonName = user1

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
email = user1@$DOMAIN
otherName = 1.3.6.1.5.2.2;SEQUENCE:krb5principal

[ krb5principal ]
realm = EXPLICIT:0,GeneralString:$REALM
principalname = EXPLICIT:1,SEQUENCE:principalname

[ principalname ]
nametype = EXPLICIT:0,INT:1
namestring = EXPLICIT:1,SEQUENCE:namestring

[ namestring ]
part1 = GeneralString:user1
EOF</code></pre>
<div class="note">
<p>The CSR’s SAN extension includes the user’s email address, and a
representation of their Kerberos principal name.</p>
</div>
<h3 id="generate-the-user-csr">Generate the User CSR <a href="#generate-the-user-csr" class="section">§</a></h3>
<pre class="command client"><code>openssl req -new \
    -key user.key \
    -config user_csr.cnf \
    -out user.csr</code></pre>
<h3 id="verify-user-csr">Verify user CSR <a href="#verify-user-csr" class="section">§</a></h3>
<pre class="command client"><code>openssl req -in user.csr -text -noout</code></pre>
<p>Verify the elliptic curve parameters in the <em>Subject Public Key
Info</em> section, and the inclusion of the user’s email address in the
<em>X509v3 Subject Alternative Name</em> extension.</p>
<h2 id="key-takeaways">Key Takeaways <a href="#key-takeaways" class="section">§</a></h2>
<ol type="1">
<li><p>You can choose the <strong>key type and size</strong>. Some CAs or
organisational policies may restrict which key types or
parameters are allowed. Current NIST standards require 3072-bit
RSA or a 256-bit elliptic curve keys as a minimum from 2031.</p></li>
<li><p><strong>CSR Customization:</strong> The configuration file allows you to
explicitly define the <strong>Subject Distinguished Name (DN)</strong> and
<strong>Subject Alternative Name (SAN)</strong> attributes.</p></li>
<li><p><strong>Use case-specific SANs:</strong> Use DNS.* for services and email
(rfc822Name) for user authentication certificates. There are
many other types of SAN values, including IP addresses (for
servers accessed directly by IP).</p></li>
</ol>
<p><strong>What’s next?</strong> You now have two distinct CSRs (<code>service.csr</code> and
<code>user.csr</code>). We are ready to move on to the next module: submitting
these CSRs to our FreeIPA CA and receiving signed X.509
certificates!</p>
</div>
<div id="nav" class="footer">
    <div class="back">
        
    </div>
    <div class="up">
        
        <a href="../index.html#toc">
            ^
            <br />
            Up to index
        </a>
        
    </div>
    <div class="next">
        
        <a href="01-keygen-and-csr.html">
            >
            <br />
            ACME certificates for Apache httpd with <code>mod_md</code>
        </a>
        
    </div>
</div>

        </div>
        <div class="clear"></div>

        <div class="footer">

<div id="license">
    <div style="float: left">
        <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/88x31.png">
        </a>
    </div>
    <div>
        <p>
        Except where otherwise noted, this work is licensed under a
        <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
            Creative Commons Attribution 4.0 International License</a>.
        </p>
    </div>
</div>

<div id="hakyll">
    Generated by
    <a href="https://jaspervdj.be/hakyll">Hakyll</a>
</div>

        </div>
    </body>
</html>
